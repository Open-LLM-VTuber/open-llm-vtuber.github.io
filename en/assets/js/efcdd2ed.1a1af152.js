"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3910],{2421:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"development-guide/live-dev","title":"Live Streaming Development","description":"The live streaming integration in this project adopts a separate process architecture, relying on a core WebSocket proxy endpoint (/proxy-ws).","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/development-guide/live-dev.md","sourceDirName":"development-guide","slug":"/development-guide/live-dev","permalink":"/en/docs/development-guide/live-dev","draft":false,"unlisted":false,"editUrl":"https://github.com/Open-LLM-VTuber/Open-LLM-VTuber-Docs/tree/main/docs/development-guide/live-dev.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"docSidebar","previous":{"title":"Development Guide Overview","permalink":"/en/docs/development-guide/overview"},"next":{"title":"API \u53c2\u8003","permalink":"/en/docs/api-reference"}}');var t=i(4848),o=i(8453);const s={sidebar_position:3},l="Live Streaming Development",c={},d=[{value:"1. Core Components and Data Flow",id:"1-core-components-and-data-flow",level:2},{value:"2. Key Interfaces and Implementations",id:"2-key-interfaces-and-implementations",level:2},{value:"2.1 <code>LivePlatformInterface</code> (Interface Definition)",id:"21-liveplatforminterface-interface-definition",level:3},{value:"2.2 WebSocket Proxy (<code>/proxy-ws</code> and <code>ProxyHandler</code>)",id:"22-websocket-proxy-proxy-ws-and-proxyhandler",level:3},{value:"2.3 <code>BiliBiliLivePlatform</code> (Bilibili Implementation Example)",id:"23-bilibililiveplatform-bilibili-implementation-example",level:3},{value:"2.4 Launcher Script (<code>run_bilibili_live.py</code>)",id:"24-launcher-script-run_bilibili_livepy",level:3},{value:"3. Steps to Develop Support for a New Platform",id:"3-steps-to-develop-support-for-a-new-platform",level:2},{value:"3.1 Create Platform Implementation Class",id:"31-create-platform-implementation-class",level:3},{value:"3.2 Add Configuration Items",id:"32-add-configuration-items",level:3},{value:"3.3 Create Run Script",id:"33-create-run-script",level:3},{value:"3.4 Run and Test",id:"34-run-and-test",level:3}];function a(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"live-streaming-development",children:"Live Streaming Development"})}),"\n",(0,t.jsxs)(n.admonition,{type:"info",children:[(0,t.jsxs)(n.mdxAdmonitionTitle,{children:["Architecture Overview: ",(0,t.jsx)(n.code,{children:"/proxy-ws"})," is the Core"]}),(0,t.jsxs)(n.p,{children:["The live streaming integration in this project adopts a ",(0,t.jsx)(n.strong,{children:"separate process"})," architecture, relying on a core ",(0,t.jsxs)(n.strong,{children:["WebSocket proxy endpoint (",(0,t.jsx)(n.code,{children:"/proxy-ws"}),")"]}),"."]}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Live Platform Client (Independent Process)"}),": Connects to specific live streaming platforms (like Bilibili), monitors events (such as danmaku/comments)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Open-LLM-VTuber Main Process"}),": Runs AI, TTS, and other core services."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Frontend UI (User Interface)"}),": Displays the Live2D model, receives user input, plays audio, etc."]}),"\n"]}),(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Key Connection Topology:"})}),(0,t.jsx)(n.mermaid,{value:'graph LR\n    A[Live Platform Client] --"text-input"--\x3e P{/proxy-ws};\n    B[Frontend UI] --"text-input/control"--\x3e P;\n    P --"forward"--\x3e H[WebSocketHandler];\n    H --"process"--\x3e AI[AI Agent];\n    AI --"response"--\x3e H;\n    H --"broadcast"--\x3e P;\n    P --"response"--\x3e B;\n    P --"optional"--\x3e A;'}),(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Legend:"})}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Live Platform Client: Live platform client (e.g., Bilibili) sends comments to the proxy (formatted as text-input)"}),"\n",(0,t.jsx)(n.li,{children:"Frontend UI: Front-end interface also sends user input and control messages to the same proxy"}),"\n",(0,t.jsx)(n.li,{children:"/proxy-ws: Core proxy endpoint, receives all messages and handles forwarding and broadcasting"}),"\n",(0,t.jsx)(n.li,{children:"WebSocketHandler: Processes messages and interacts with AI"}),"\n",(0,t.jsx)(n.li,{children:"AI Agent: Generates responses"}),"\n",(0,t.jsx)(n.li,{children:"AI responses are ultimately broadcast via the proxy to all connected clients (including the frontend and live platform client)"}),"\n"]}),(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Core Requirement:"})," For live comments to be processed by the AI, and for AI responses to be correctly displayed in the frontend, ",(0,t.jsxs)(n.strong,{children:["all clients (including the frontend UI and live platform client) must connect to the same ",(0,t.jsx)(n.code,{children:"/proxy-ws"})," endpoint"]}),"."]}),(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:["The Role of ",(0,t.jsx)(n.code,{children:"/proxy-ws"})," (",(0,t.jsx)(n.code,{children:"ProxyHandler"}),"):"]})}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Unified Entry Point:"})," Provides a single connection point for all types of clients."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Message Routing:"})," Receives messages from all clients and processes or forwards them to the ",(0,t.jsx)(n.code,{children:"WebSocketHandler"})," based on type (e.g., ",(0,t.jsx)(n.code,{children:"text-input"}),", ",(0,t.jsx)(n.code,{children:"interrupt-signal"}),", etc.)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Message Queue:"})," Queues ",(0,t.jsx)(n.code,{children:"text-input"})," type messages (from frontend or live platform) to ensure AI responds sequentially."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"State Synchronization:"})," Manages connection states, such as marking whether a conversation is active (",(0,t.jsx)(n.code,{children:"conversation_active"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Broadcasting:"})," Broadcasts messages from the backend ",(0,t.jsx)(n.code,{children:"WebSocketHandler"})," (such as AI responses, status updates) to all connected clients."]}),"\n"]})]}),"\n",(0,t.jsx)(n.h2,{id:"1-core-components-and-data-flow",children:"1. Core Components and Data Flow"}),"\n",(0,t.jsxs)(n.p,{children:["Using Bilibili live streaming as an example, here's the complete flow from ",(0,t.jsx)(n.strong,{children:"comment input"})," to ",(0,t.jsx)(n.strong,{children:"AI response"})," (assuming both the frontend and Bilibili client are connected to ",(0,t.jsx)(n.code,{children:"/proxy-ws"}),"):"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Viewer"})," -> ",(0,t.jsx)(n.strong,{children:"Bilibili Server"}),": Sends a comment."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Bilibili Server"})," -> ",(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"run_bilibili_live.py"})," (Independent Process)"]}),": The ",(0,t.jsx)(n.code,{children:"blivedm"})," library receives the comment event."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"run_bilibili_live.py"})})," -> ",(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"/proxy-ws"})," (Main Process)"]}),": ",(0,t.jsx)(n.code,{children:"BiliBiliLivePlatform"})," formats the comment as ",(0,t.jsx)(n.code,{children:'{"type": "text-input", "text": "comment content"}'})," and sends it to ",(0,t.jsx)(n.code,{children:"/proxy-ws"})," via WebSocket."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"/proxy-ws"})," (",(0,t.jsx)(n.code,{children:"ProxyHandler"}),")"]})," -> ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"WebSocketHandler"})}),": ",(0,t.jsx)(n.code,{children:"ProxyHandler"})," receives the message and, because its type is ",(0,t.jsx)(n.code,{children:"text-input"}),", places it in the message queue (",(0,t.jsx)(n.code,{children:"ProxyMessageQueue"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"ProxyMessageQueue"})})," -> ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"ProxyHandler.forward_to_server"})}),": When it's this message's turn to be processed, the queue retrieves it and sends it to ",(0,t.jsx)(n.code,{children:"WebSocketHandler"})," via ",(0,t.jsx)(n.code,{children:"forward_to_server"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"WebSocketHandler"})}),": Receives the ",(0,t.jsx)(n.code,{children:"text-input"})," message, triggering conversation processing logic (",(0,t.jsx)(n.code,{children:"_handle_conversation_trigger"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"WebSocketHandler"})})," -> ",(0,t.jsx)(n.strong,{children:"AI Agent"}),": Passes the comment text (",(0,t.jsx)(n.code,{children:'"comment content"'}),") as user input to the AI model."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"AI Agent"})," -> ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"WebSocketHandler"})}),": AI returns a response text stream."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"WebSocketHandler"})})," -> ",(0,t.jsx)(n.strong,{children:"TTS/Expression/Action Processing"}),": Processes the AI response."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"WebSocketHandler"})})," -> ",(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"/proxy-ws"})," (",(0,t.jsx)(n.code,{children:"ProxyHandler"}),")"]}),": Sends the processed results (text, audio, instructions, etc.) back to ",(0,t.jsx)(n.code,{children:"ProxyHandler"})," for broadcasting."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"/proxy-ws"})," (",(0,t.jsx)(n.code,{children:"ProxyHandler"}),")"]})," -> ",(0,t.jsx)(n.strong,{children:"All Connected Clients (including Frontend UI)"}),": ",(0,t.jsx)(n.code,{children:"ProxyHandler"})," calls ",(0,t.jsx)(n.code,{children:"broadcast_to_clients"})," to broadcast the AI's response to all clients connected to ",(0,t.jsx)(n.code,{children:"/proxy-ws"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Frontend UI"}),": Receives the broadcast message, plays audio, displays text, executes expressions/actions."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"2-key-interfaces-and-implementations",children:"2. Key Interfaces and Implementations"}),"\n",(0,t.jsxs)(n.h3,{id:"21-liveplatforminterface-interface-definition",children:["2.1 ",(0,t.jsx)(n.code,{children:"LivePlatformInterface"})," (Interface Definition)"]}),"\n",(0,t.jsxs)(n.p,{children:["(Located in ",(0,t.jsx)(n.code,{children:"src/open_llm_vtuber/live/live_interface.py"}),")"]}),"\n",(0,t.jsxs)(n.p,{children:["An abstract base class that all live platform client implementations must adhere to. The core requirement is to implement the ",(0,t.jsx)(n.code,{children:"connect"})," method to connect to the ",(0,t.jsxs)(n.strong,{children:["proxy endpoint ",(0,t.jsx)(n.code,{children:"/proxy-ws"})]}),", and implement the ",(0,t.jsx)(n.code,{children:"run"})," method to monitor platform events and format them as ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:'{"type": "text-input", ...}'})})," before sending them to the proxy via ",(0,t.jsx)(n.code,{children:"_send_to_proxy"}),"."]}),"\n",(0,t.jsxs)(n.h3,{id:"22-websocket-proxy-proxy-ws-and-proxyhandler",children:["2.2 WebSocket Proxy (",(0,t.jsx)(n.code,{children:"/proxy-ws"})," and ",(0,t.jsx)(n.code,{children:"ProxyHandler"}),")"]}),"\n",(0,t.jsxs)(n.p,{children:["(Endpoint defined in ",(0,t.jsx)(n.code,{children:"src/open_llm_vtuber/routes.py"}),", implemented in ",(0,t.jsx)(n.code,{children:"src/open_llm_vtuber/proxy_handler.py"}),")"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Core component"}),", responsible for:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Receiving messages from ",(0,t.jsx)(n.strong,{children:"all"})," connected clients (frontend UI, live platform clients)."]}),"\n",(0,t.jsxs)(n.li,{children:["Queuing ",(0,t.jsx)(n.code,{children:"text-input"})," messages before forwarding them to ",(0,t.jsx)(n.code,{children:"WebSocketHandler"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Directly forwarding other control messages to ",(0,t.jsx)(n.code,{children:"WebSocketHandler"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Broadcasting"})," responses from ",(0,t.jsx)(n.code,{children:"WebSocketHandler"})," to all connected clients."]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"23-bilibililiveplatform-bilibili-implementation-example",children:["2.3 ",(0,t.jsx)(n.code,{children:"BiliBiliLivePlatform"})," (Bilibili Implementation Example)"]}),"\n",(0,t.jsxs)(n.p,{children:["(Located in ",(0,t.jsx)(n.code,{children:"src/open_llm_vtuber/live/bilibili_live.py"}),")"]}),"\n",(0,t.jsxs)(n.p,{children:["An implementation of ",(0,t.jsx)(n.code,{children:"LivePlatformInterface"}),". The key is the ",(0,t.jsx)(n.code,{children:"_send_to_proxy"})," method which formats comments as ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:'{"type": "text-input", ...}'})})," before sending them to ",(0,t.jsx)(n.code,{children:"/proxy-ws"}),"."]}),"\n",(0,t.jsxs)(n.h3,{id:"24-launcher-script-run_bilibili_livepy",children:["2.4 Launcher Script (",(0,t.jsx)(n.code,{children:"run_bilibili_live.py"}),")"]}),"\n",(0,t.jsxs)(n.p,{children:["(Located in ",(0,t.jsx)(n.code,{children:"scripts/run_bilibili_live.py"}),")"]}),"\n",(0,t.jsxs)(n.p,{children:["An independent process launcher, responsible for instantiating ",(0,t.jsx)(n.code,{children:"BiliBiliLivePlatform"})," and calling its ",(0,t.jsx)(n.code,{children:"run"})," method, enabling it to connect to ",(0,t.jsx)(n.code,{children:"/proxy-ws"})," and start monitoring Bilibili events."]}),"\n",(0,t.jsx)(n.h2,{id:"3-steps-to-develop-support-for-a-new-platform",children:"3. Steps to Develop Support for a New Platform"}),"\n",(0,t.jsx)(n.h3,{id:"31-create-platform-implementation-class",children:"3.1 Create Platform Implementation Class"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Create a new class ",(0,t.jsx)(n.code,{children:"MyPlatformLive"})," inheriting from ",(0,t.jsx)(n.code,{children:"LivePlatformInterface"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Implement all abstract methods, especially ",(0,t.jsx)(n.code,{children:"connect"})," (connects to ",(0,t.jsx)(n.code,{children:"/proxy-ws"}),") and ",(0,t.jsx)(n.code,{children:"run"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["In ",(0,t.jsx)(n.code,{children:"run"})," or its called event handlers, receive platform messages (like comments)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:["Implement ",(0,t.jsx)(n.code,{children:"_send_to_proxy(self, text: str)"})]}),": ",(0,t.jsx)(n.strong,{children:"Must"})," package ",(0,t.jsx)(n.code,{children:"text"})," as ",(0,t.jsx)(n.code,{children:'{"type": "text-input", "text": text}'})," JSON, and send it to the proxy (",(0,t.jsx)(n.code,{children:"/proxy-ws"}),") via ",(0,t.jsx)(n.code,{children:"self._websocket.send()"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# src/open_llm_vtuber/live/my_platform_live.py (key parts example)\n# ... (imports) ...\n\nclass MyPlatformLive(LivePlatformInterface):\n    # ... (implement __init__, connect, disconnect, run, etc.) ...\n\n    async def _handle_platform_event(self, event_data):\n        message_text = event_data.get(\'message\')\n        if message_text:\n            logger.info(f"Received from My Platform: {message_text}")\n            # Call method to send to proxy\n            await self._send_to_proxy(message_text)\n\n    async def _send_to_proxy(self, text: str) -> bool:\n        if not self.is_connected:\n            logger.error("Cannot send message: Not connected to proxy")\n            return False\n        try:\n            # !!! Core: Format as text-input type !!!\n            payload = {"type": "text-input", "text": text}\n            await self._websocket.send(json.dumps(payload))\n            logger.info(f"Sent formatted message to proxy: {text}")\n            return True\n        except Exception as e:\n            # ... (error handling)\n            return False\n\n    async def run(self) -> None:\n        # Ensure connection to proxy proxy_url = "ws://localhost:12393/proxy-ws"\n        # ... (connection logic) ...\n        # --- Your platform event monitoring logic --- #\n        # while self._running:\n        #     event = await my_platform_sdk.get_next_event()\n        #     await self._handle_platform_event(event)\n        # ----------------------------- #\n        # ... (cleanup logic) ...\n'})}),"\n",(0,t.jsx)(n.h3,{id:"32-add-configuration-items",children:"3.2 Add Configuration Items"}),"\n",(0,t.jsx)(n.p,{children:"To allow your live platform client to be configured and initialized correctly, you need to:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Define a Pydantic Configuration Model"}),": In the ",(0,t.jsx)(n.code,{children:"src/open_llm_vtuber/config_manager/live.py"})," file, create a new configuration class similar to ",(0,t.jsx)(n.code,{children:"BiliBiliLiveConfig"}),". For instance, if your platform requires a ",(0,t.jsx)(n.code,{children:"channel_id"})," and an ",(0,t.jsx)(n.code,{children:"api_token"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# src/open_llm_vtuber/config_manager/live.py\nfrom pydantic import BaseModel, Field\nfrom typing import Dict, ClassVar, List # Ensure BaseModel is imported\nfrom .i18n import I18nMixin, Description\n\n# ... (BiliBiliLiveConfig definition) ...\n\nclass MyPlatformConfig(I18nMixin): # Inherit I18nMixin (optional, for i18n descriptions)\n    """Configuration for My Platform Live integration."""\n    channel_id: str = Field("", alias="channel_id")\n    api_token: str = Field("", alias="api_token")\n    # Add other necessary configuration items with default values\n\n    DESCRIPTIONS: ClassVar[Dict[str, Description]] = {\n        "channel_id": Description(en="Channel ID for My Platform", zh="My Platform \u7684\u9891\u9053 ID"),\n        "api_token": Description(en="API Token for My Platform", zh="My Platform \u7684 API Token"),\n    }\n\nclass LiveConfig(I18nMixin):\n    """Configuration for live streaming platforms integration."""\n    bilibili_live: BiliBiliLiveConfig = Field(\n        default_factory=BiliBiliLiveConfig, alias="bilibili_live"\n    )\n    # !!! Add your platform config to LiveConfig !!!\n    my_platform: MyPlatformConfig = Field(\n        default_factory=MyPlatformConfig, alias="my_platform"\n    )\n    # ... potentially other platforms ...\n\n    DESCRIPTIONS: ClassVar[Dict[str, Description]] = {\n        "bilibili_live": Description(\n            en="Configuration for BiliBili Live platform", zh="B\u7ad9\u76f4\u64ad\u5e73\u53f0\u914d\u7f6e"\n        ),\n        "my_platform": Description(\n            en="Configuration for My Platform", zh="My Platform \u914d\u7f6e"\n        ),\n    }\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Update Default Configuration Files"}),": In the ",(0,t.jsx)(n.code,{children:"conf.default.yaml"})," and ",(0,t.jsx)(n.code,{children:"conf.ZH.default.yaml"})," files in the project root, add your platform's configuration keys and default values under the ",(0,t.jsx)(n.code,{children:"live_config:"})," section. This informs users about the available settings."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'# conf.default.yaml / conf.ZH.default.yaml\nlive_config:\n  bilibili_live:\n    room_ids: []\n    sessdata: ""\n  # Add your platform\'s configuration\n  my_platform:\n    channel_id: ""\n    api_token: ""\n    # Other default values...\n'})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"33-create-run-script",children:"3.3 Create Run Script"}),"\n",(0,t.jsxs)(n.p,{children:["The run script serves as the entry point for launching your independent live platform client process. You need to create a script similar to ",(0,t.jsx)(n.code,{children:"scripts/run_bilibili_live.py"}),"."]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Create a new file in the ",(0,t.jsx)(n.code,{children:"scripts/"})," directory, e.g., ",(0,t.jsx)(n.code,{children:"run_my_platform_live.py"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["The core logic of the script involves:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Importing necessary modules, including your ",(0,t.jsx)(n.code,{children:"MyPlatformLive"})," class and configuration utilities."]}),"\n",(0,t.jsxs)(n.li,{children:["Reading the main configuration file (",(0,t.jsx)(n.code,{children:"conf.yaml"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:["Validating the configuration and extracting the specific configuration section for your platform (e.g., ",(0,t.jsx)(n.code,{children:"config.live_config.my_platform"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:["Instantiating your ",(0,t.jsx)(n.code,{children:"MyPlatformLive"})," class, passing the configuration to it (usually by converting the Pydantic model to a dictionary using ",(0,t.jsx)(n.code,{children:".model_dump()"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:["Calling ",(0,t.jsx)(n.code,{children:"platform.run()"})," to start the client."]}),"\n",(0,t.jsx)(n.li,{children:"Including basic asynchronous execution and exception handling logic."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# scripts/run_my_platform_live.py\nimport asyncio\nimport sys\nimport os\nfrom loguru import logger\n\n# Ensure modules from the src directory can be imported\nproject_root = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))\nsys.path.insert(0, project_root)\n\n# !!! Import your platform implementation class !!!\nfrom src.open_llm_vtuber.live.my_platform_live import MyPlatformLive\nfrom src.open_llm_vtuber.config_manager.utils import read_yaml, validate_config\n\nasync def main():\n    logger.info("Starting My Platform Live client")\n    try:\n        # Read the main configuration\n        config_path = os.path.join(project_root, "conf.yaml")\n        config_data = read_yaml(config_path)\n        config = validate_config(config_data)\n\n        # !!! Get your platform\'s configuration !!!\n        my_platform_config = config.live_config.my_platform\n\n        # !!! (Optional) Check if critical configurations exist !!!\n        # if not my_platform_config.channel_id or not my_platform_config.api_token:\n        #     logger.error("Missing required configuration for My Platform (channel_id or api_token)")\n        #     return\n\n        logger.info(f"Attempting to connect to My Platform channel: {my_platform_config.channel_id}")\n\n        # !!! Instantiate your platform client, passing the config !!!\n        # Pass the Pydantic model as a dictionary\n        platform = MyPlatformLive(config=my_platform_config.model_dump())\n\n        # !!! Start the client !!!\n        await platform.run()\n\n    except ImportError as e:\n         logger.error(f"Failed to import required modules: {e}")\n         # May need to prompt user to install specific dependencies: logger.error("Did you install my_platform_sdk?")\n    except Exception as e:\n        logger.error(f"Error starting My Platform Live client: {e}")\n        import traceback\n        logger.debug(traceback.format_exc())\n\nif __name__ == "__main__":\n    try:\n        # Run the main function using asyncio\n        asyncio.run(main())\n    except KeyboardInterrupt:\n        # Graceful shutdown\n        logger.info("Shutting down My Platform Live client")\n'})}),"\n",(0,t.jsx)(n.h3,{id:"34-run-and-test",children:"3.4 Run and Test"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Install dependencies."}),"\n",(0,t.jsxs)(n.li,{children:["Configure ",(0,t.jsx)(n.code,{children:"conf.yaml"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Start the main program (",(0,t.jsx)(n.code,{children:"uv run run_server.py"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:["Ensure the frontend UI connects to ",(0,t.jsx)(n.code,{children:"/proxy-ws"})]})," (modify the WebSocket URL in frontend settings)."]}),"\n",(0,t.jsxs)(n.li,{children:["In another terminal, start the platform script (",(0,t.jsx)(n.code,{children:"uv run python scripts/run_my_platform_live.py"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:["Send a message on the live platform, observe the main program logs and the ",(0,t.jsx)(n.strong,{children:"frontend UI's response"}),"."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>l});var r=i(6540);const t={},o=r.createContext(t);function s(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);